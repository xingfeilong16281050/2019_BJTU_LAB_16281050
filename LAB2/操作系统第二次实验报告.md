## 操作系统第二次实验报告

#### 一、打开一个vi进程。通过ps命令以及选择合适的参数，只显示名字为vi的进程。寻找vi进程的父进程，直到init进程为止。记录过程中所有进程的ID和父进程ID。将得到的进程树和由pstree命令的得到的进程树进行比较。

打开进程：

![1.1代码](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\1.1代码.jpg)

![1.1运行程序](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\1.1运行程序.jpg)

查找进程并进行父进程的追踪：

![路径追踪一](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\路径追踪一.jpg)

![路径追踪2](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\路径追踪2.jpg)

![路径追踪3](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\路径追踪3.jpg)

通过追踪父进程，我们可以得到进程树：

![进程树](C:\Users\emrick\Desktop\进程树.jpg)

和pstree显示的进程树进行比较：

![tree](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\tree.jpg)

我们发现路径是相同的。

#### 二、编写程序，首先使用fork系统调用，创建子进程。在父进程中继续执行空循环操作；在子进程中调用exec打开vi编辑器。然后在另外一个终端中，通过ps –Al命令、ps aux或者top等命令，查看vi进程及其父进程的运行状态，理解每个参数所表达的意义。选择合适的命令参数，对所有进程按照cpu占用率排序。

代码：

![2代码](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\2代码.jpg)

查看进程：

![2.1](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\2.1.jpg)

各个参数含义：

![1552564610763](C:\Users\emrick\AppData\Roaming\Typora\typora-user-images\1552564610763.png)

CPU占用率排序：都占用0%

打开火狐浏览器：使用 ps -Al 查看：![2.2](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\2.2.jpg)

可以看到不是0%的只有浏览器和web服务的进程，其中浏览器最多占40%

#### 三、使用fork系统调用，创建如下进程树，并使每个进程输出自己的ID和父进程的ID。观察进程的执行顺序和运行状态的变化。

![img](file:///C:\Users\emrick\AppData\Local\Temp\ksohtml5628\wps1.png)

代码如下：

![3代码](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\3代码.jpg)

运行结果：

![3运行结果](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\3运行结果.jpg)

可以看到输出的顺序为P1 ->P2->P4->P5->P3(看起来像前序遍历)

#### 四、修改上述进程树中的进程，使得所有进程都循环输出自己的ID和父进程的ID。然后终止p2进程(分别采用kill -9 、自己正常退出exit()、段错误退出)，观察p1、p3、p4、p5进程的运行状态和其他相关参数有何改变。

代码：![1552569252734](C:\Users\emrick\AppData\Roaming\Typora\typora-user-images\1552569252734.png)

开始时我在每个进程前加上了wait（0）；

导致子进程不结束父进程就会一直处于等待状态，只有kill掉当前子进程才会执行父进程，有如下结果：

![4有wait](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\4有wait.jpg)

去掉wait之后就会正常的进行输出：

![4正常输出](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\4正常输出.jpg)

kill掉P2后：

![4kill](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\4kill.jpg)

可以看到kill掉p2之后p2的两个子进程父进程就发生了改变，直接变成了2300（P1的父进程）这是因为在计算机中不允许进程没有父进程（root除外）。

如果是正常的exit运行如下（修改P2进程为循环5次推出）：![4exit](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\4exit.jpg)

可以看到在五次循环后p2正常exit，这时和上面的kill情况时相同的，P4P5直接变为了2300；

修改代码进行段错误退出（访问数组越界）：

![4kill2](C:\Users\emrick\Desktop\大三下课程\操作系统\作业\第二次试验\截图\4kill2.jpg)

结果和上面相同。



